---
layout: post
title:      "Commit. Learn. Initialize"
date:       2020-08-09 14:54:28 +0000
permalink:  commit_learn_initialize
---






There's something to be said about the consistency required as a beginner in a new venture. Once I enrolled in Flatiron I knew about the highs and lows I would soon face. These same highs and lows were reinforced by my educational coach Talia. She explained to the class that we'd go through cycles were we feel super confident and then we'll feel at our lowest lows and probably even consider quitting. Safe to say during this CLI project, I felt all of those things. Going into project week felt like I was traveling into uncharted territory, after all it was my first project and I was a bit behind on my lessons. How could I possibly get through this? As long as I've known myself, I've never been a quitter and today wasn't the day I was going to start!



The project planning phase was easy as can be. I've started so many creative things from scratch by this point that it's second nature to me. I would incorporate something that I was familiar with and I'd integrate my learning into it. I've invested in stocks for some time now. I'd consider myself a passive investor. But as with learning code, fundamentals are essential. My app would be a foundational peek into the world of investing. I'd meet all the requirements while building something that could be used by an everyday consumer. Introducing the user to both command line interfaces as well as how the stock market operates. The plan was to give the user the option to see the highest gainer on the stock market for the day, as well as the lowest. I'd then go another level deeper and allow the user to search for stocks on their own by entering a ticker symbol of their choice that would return the company name as well as the current share price. As the user got familiar with this process a portfolio begins to build in the back-end. The user can then check their portfolio of stocks at any point white the click of a button. This then returns a beautifully laid out interface that shows all their recent inquires in a Name: and Price: format. 



Incorporating several different disciplines was the trick here. I'd build three different classes.



**An API Class** - This was perhaps the most important class of the three. I wanted the functionality to be as static as possible because the options would be so clear cut. I pulled my API from Yahoo FInance using Rapid API. Yahoo Finance's API provided me with an abundance of information, all valuable. I felt like I had come across a gold mine! Although I had access to all the information in the JSON file: *market analysis*, *quotes*, *prices*, *yields*, *P/E ratio's*, etc. I wanted to keep it as simple as possible. Those aforementioned things would confuse the user (in my opinion) and possibly drive them away from diving further into the interface. Simplicity is the highest form of sophistication , Leonardo Davinci once said. Keeping it simple was the aim here. I'd use two different versions of this API. One to give me the biggest gainers in the market for the day as well as the biggest losers. The second instance would be to pull information from a stock using a ticker symbol. This API actually required a parameter (the ticker symbol). This was the first hurdle I would encounter and perhaps the most frustrating one. I could use the prebuilt code that the API came with, which generated a URL that the HTTP response would get it's information from. But doing so would limit the user to seeing information from that stock and that stock only...every single time. Where's the fun in that? The ability to be rigid in your goals but fluid in your approach is something I live by. An app that gives the user the option to "choose" their own stock using a ticker symbol of their choice but the app returning the same number completely defeats that purpose. Luckily enough, I'm a software engineer in the making and I've learned how to get past this! I noticed that the overall URL didn't change much when the ticker symbol was changed. So something I learned in the First Mile would come in handy! Interpolation. I went into the actual API code and swapped out the static ticker symbol with "#{symbol}" giving the user the ability to input their own ticker which would then generate the URL but end it with their ticker symbol and then the HTTP response would be their personalized ticker symbol. Voila, magic. Just like that my problem was solved. My API class was set up and functioned exactly how I had imagined.





**A Stock Class** - Now given that the API class was constructed to show the biggest movers and gainers. Had I stopped there, there would be no need for this class. That information was dynamic and while I could have possibly made some sort of use for that information. It would be problematic or require a different programming language to make that information more useful beyond "here's todays information..". However, since the API class also had the second option which was my favorite. The option to search stocks by name, I found a use for this class. This class would serve as the bucket for the stocks the user would inquire about . Using an empty array that shoveled in each custom ticker, this class served as the unsung hero for this project. I may not have much to say about it, but it's importance is far greater than any amount of words I can say about it.





**The CLI Class** - The workhorse . This class brought the previous two together in holy matrimony . It's as if they were puzzle pieces that just fit together. The approach was simple. The first method would be the meat and potatoes. Introduce the program, ask the user for their name. On the front end this is represented in a simple, beautiful string of characters *"Hello, I'm your Stock Assistant. May I have your name?"* it's as if I recreated Ask Jeeves but in the form of a stock assistant. The user is welcomed by their digital stock concierge, enters their name and is met with the response *"Hello (name)! I am your personal stock advisor."*  Personal? Advisor? What better way to make one feel safe and at home than a greeting like that? I chose to colorize the responses from the Advisor to make it even more personalized. All white text just seemed a little bland for me, I had to add a little pizzazz. That coupled with the alternating colored text in the menu options was sure to be eye catching and elegant. I said it'd be simple, I never said it wouldn't be elegant. The user is then prompted to input their choices from the beautifully laid out menu. While the CLI class is behind the scenes reading case statements and going through a constant loop declaring each input (but one) as nil to make the user experience as seemless as possible. If I hadn't designed this interface myself I'd be impressed. But enough tooting my own horn, lets go back under the hood. The top of the class pulls in information from the API class, it uses the "gets" keyword to allow the user to input their name. it then interpolates the information and spits out the personalized response while subtly preparing itself for whats in store by pulling in information from the API class. It then calls the menu method discretely as it moves on to the next method. As I mentioned before this next method, the menu method utilizes an Until loop and Case statements. The until loop is simple, return the menu to allow the user a seemingly on demand experience Until they CHOOSE to exit the program. Appropriately colored red, the exit function then gives the user a final goodbye and closes out the menu. The case statements seemed appropriate to me given that I'd be using so many options. I could have used the conditional if, elsif and else but those are so rudimentary, whereas Case and When has a certain je na sais quoi to it. If I'm creating an elegant program, then I'm going to use elegant means to reach that end. The fourth option in my case statement is where everything ties in together. This option returns the users portfolio. This option works in tandem with the third option. The third option calls the method from the API class that allows the user to choose custom stocks. The fourth then calls on all those instances from the Stock class and returns them in a chic minimalistic menu with the stock name accented in an emerald-green text. 



It's been 56 days since I started Flatiron. They say it takes 29 days to make something a habit. That means coding has been my habit almost twice over. Consistency allowed me to get through this CLI project, consistency will allow me to further develop my coding skills and design more beautiful apps in the future.


